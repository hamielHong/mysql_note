mysql 事务
===

使用
---

``` sql
START TRANSACTION;
SELECT %sth% FROM %sth% WHERE %sth%;
UPDATE %sth%;
COMMIT
```

ACID
---

ACID指事务的四个特性，分别是：

1. 原子性(atomicity)

    一个事物必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，不可能只执行其中的一部分操作。

2. 一致性(consistency)

    数据库总是从一个一致性的状态转换到另一个一致性的状态。

3. 隔离性(isolation)

    通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。

4. 持久性(durability)

    一旦事务被提交，则其所做的修改就会永久保存到数据库中。实际上持久性也分很多不同的级别，有些持久性策略能够提供非常强的安全保障，有些则未必。不可能做到100%的持久性保证的策略（数据库本身做不到真正的持久性，备份能增加持久性）。

隔离级别
---

SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

1. READ UNCOMMITED(未提交读)

    在这个级别，事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，也叫 **脏读(Dirty Read)**，会导致很多问题。从性能上来说，这个级别不会比其他级别好太多，但却缺乏其他级别的很多好处，在实际应用中很少使用。

2. READ COMMIT(提交读)/NONREPEATABLE(不可重复读)

    大多数数据库的默认隔离级别都是这个级别（但MySQL不是）。这个级别满足隔离性的简单定义，但事务内部两次执行同样的查询，可能会的到不一样的结果。

3. REPEATABLE READ(可重复读)

    这个级别解决了脏读的问题。保证在同一个事务中多次读取同样的记录的结果是一致的。理论上无法解决 **幻读(Phantom Read)** 问题。所谓幻读，值得是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生 **幻行(Phantom Row)**。InnoDB和XtraDB存储引擎通过多版本并发控制(MVCC, Multiversion Concurrency Control) 解决了幻读的问题。

    这个级别是MySQL默认的事务隔离级别。

4. SERIALIZABLE(可串行化)

    最高的隔离级别。通过强制事务串行执行，避免了幻读的问题。简单来所，该级别会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。只有在非常需要确保数据的一致性并且可以接受没有并发的情况下，才考虑采用该级别。

| 隔离级别 | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加读锁 |
|---|---|---|---|---|
|READ UNCOMMITED|Yes|Yes|Yes|No|
|READ COMMIT|No|Yes|Yes|No|
|REPEATABLE READ|No|No|Yes|No|
|SERIALIZABLE|No|No|No|Yes|

多版本并发控制
---

MVCC实现，典型的有 **乐观(optimistic)** 并发控制和 **悲观(pessimistic)** 并发控制。